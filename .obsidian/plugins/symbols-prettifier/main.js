/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SymbolsPrettifier
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/search.ts
var SearchCursor = class {
  constructor(text, regex, _originalCaret) {
    this.text = text;
    this._originalCaret = _originalCaret;
    if (regex instanceof RegExp) {
      this.regex = regex;
    } else {
      this.regex = new RegExp(regex);
    }
    this.reset();
  }
  reset() {
    this._from = this._originalCaret;
    this._to = this._originalCaret;
    this._caret = this._originalCaret;
  }
  findNext() {
    const text = this.text.slice(this._caret);
    const match = text.match(this.regex);
    if ((match == null ? void 0 : match.index) == null) {
      return void 0;
    }
    this._from = this._caret + match.index;
    this._to = this._caret + match.index + match[0].length;
    this._caret = this._to;
    return match;
  }
  findPrevious() {
    const reverseRegex = new RegExp(`(?<full>${this.regex.source})(?!.*[\\r\\n]*.*\\k<full>)`, this.regex.flags);
    const text = this.text.slice(0, this._caret);
    const lastMatch = text.match(reverseRegex);
    if ((lastMatch == null ? void 0 : lastMatch.index) == null || (lastMatch == null ? void 0 : lastMatch.groups) == null) {
      return void 0;
    }
    this._from = lastMatch.index;
    this._to = lastMatch.index + lastMatch.groups.full.length;
    this._caret = this._from;
    return lastMatch;
  }
  to() {
    return this._to;
  }
  from() {
    return this._from;
  }
};

// src/main.ts
var characterMap = {
  "->": "\u2192",
  "<-": "\u2190",
  "<->": "\u2194",
  "<=>": "\u21D4",
  "<=": "\u21D0",
  "=>": "\u21D2",
  "--": "\u2013",
  "!important": {
    transform: "!important",
    classes: "symbols-prettifier-important",
    element: '<span class="symbols-prettifier-important">!important</span>'
  },
  "?unclear": {
    transform: "?unclear",
    classes: "symbols-prettifier-unclear",
    element: '<span class="symbols-prettifier-unclear">?unclear</span>'
  }
};
var SymbolsPrettifier = class extends import_obsidian.Plugin {
  onload() {
    console.log("loading symbols prettifier");
    this.addCommand({
      id: "symbols-prettifier-add-important",
      name: "Add important symbol",
      editorCallback: (editor) => {
        const cursor = editor.getCursor();
        const symbol = characterMap["!important"];
        if (typeof symbol !== "string") {
          editor.replaceRange(symbol.element, cursor);
        }
      }
    });
    this.addCommand({
      id: "symbols-prettifier-add-unclear",
      name: "Add unclear symbol",
      editorCallback: (editor) => {
        const cursor = editor.getCursor();
        const symbol = characterMap["?unclear"];
        if (typeof symbol !== "string") {
          editor.replaceRange(symbol.element, cursor);
        }
      }
    });
    this.addCommand({
      id: "symbols-prettifier-format-symbols",
      name: "Prettify existing symbols in document",
      editorCallback: (editor) => {
        let value = editor.getValue();
        const codeBlocks = this.getCodeBlocks(value);
        let matchedChars = [];
        const matchChars = Object.entries(characterMap).reduce((prev, [curr]) => {
          if (prev.length === 0) {
            return prev + this.escapeRegExp(curr);
          }
          return prev + "|" + this.escapeRegExp(curr);
        }, "");
        const searchCursor = new SearchCursor(value, new RegExp("(?<![\\w\\d])" + matchChars + "(?![\\w\\d])"), 0);
        while (searchCursor.findNext() !== void 0) {
          matchedChars.push({
            from: searchCursor.from(),
            to: searchCursor.to()
          });
        }
        matchedChars = matchedChars.filter((matchedChar) => {
          return !codeBlocks.some((cb) => cb.from <= matchedChar.from && cb.to >= matchedChar.to);
        });
        let diff = 0;
        matchedChars.forEach((matchedChar) => {
          const symbol = value.substring(matchedChar.from - diff, matchedChar.to - diff);
          const character = characterMap[symbol];
          if (typeof character === "string") {
            value = value.substring(0, matchedChar.from - diff) + character + value.substring(matchedChar.to - diff);
            diff += symbol.length - character.length;
          } else {
            value = value.substring(0, matchedChar.from - diff) + character.element + value.substring(matchedChar.to - diff);
            diff += symbol.length - character.element.length;
          }
        });
        editor.setValue(value);
      }
    });
    this.registerDomEvent(document, "keydown", (event) => {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (view) {
        const cursor = view.editor.getCursor();
        if (event.key === " ") {
          const line = view.editor.getLine(cursor.line);
          let from = -1;
          let sequence = "";
          for (let i = cursor.ch - 1; i >= 0; i--) {
            if (line.charAt(i) === " ") {
              const excludeWhitespace = i + 1;
              from = excludeWhitespace;
              sequence = line.slice(excludeWhitespace, cursor.ch);
              break;
            } else if (i === 0) {
              from = i;
              sequence = line.slice(i, cursor.ch);
              break;
            }
          }
          const replaceCharacter = characterMap[sequence];
          if (replaceCharacter && from !== -1 && !this.isCursorInCodeBlock(view.editor)) {
            if (typeof replaceCharacter === "string") {
              view.editor.replaceRange(replaceCharacter, { line: cursor.line, ch: from }, { line: cursor.line, ch: cursor.ch });
            } else {
              view.editor.replaceRange(`<span class="${replaceCharacter.classes}">${replaceCharacter.transform}</span>`, { line: cursor.line, ch: from }, { line: cursor.line, ch: cursor.ch });
            }
          }
        }
      }
    });
  }
  onunload() {
    console.log("unloading symbols prettifier");
  }
  escapeRegExp(string) {
    return string.replace(/[.*+?^!${}()|[\]\\]/g, "\\$&");
  }
  getCodeBlocks(input) {
    const result = [];
    const codeBlock = /```\w*[^`]+```/;
    const searchCursor = new SearchCursor(input, codeBlock, 0);
    while (searchCursor.findNext() !== void 0) {
      result.push({ from: searchCursor.from(), to: searchCursor.to() });
    }
    return result;
  }
  isCursorInCodeBlock(editor) {
    const codeBlock = /```\w*[^`]+```/;
    const searchCursor = new SearchCursor(editor.getValue(), codeBlock, 0);
    let cursor;
    while ((cursor = searchCursor.findNext()) !== void 0) {
      const offset = editor.posToOffset(editor.getCursor());
      if (searchCursor.from() <= offset && searchCursor.to() >= offset) {
        return true;
      }
    }
    return false;
  }
};
