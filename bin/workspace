#!/usr/bin/env bash

usage() {
    echo "Usage: $0 [--worktree] <command> [options]"
    echo ""
    echo "  open [path]             Open existing directory (uses fzf to find git projects if no path given)"
    echo "  close [name]            Kill tmux session (auto-detects if omitted)"
    echo "  minimize [name]         Close all nvim panes in tmux session (auto-detects if omitted)"
    echo "  help                    Show this help"
    echo ""
    echo "Modes:"
    echo "  --worktree             Enable worktree mode (git worktrees)"
    echo "                          Without this flag, runs in sessionizer mode"
    echo ""
    echo "Worktree Mode Commands (requires --worktree):"
    echo "  create <branch_name>    Create new git worktree and open tmux session"
    echo "  remove [branch_name]    Remove git worktree (auto-detects if omitted)"
    echo "  prune [--force]         Remove all unused worktrees"
    echo "                          --force: Also remove worktrees with uncommitted changes"
    echo "  --setup                 Run \$WORKSPACE_INTERNAL_SETUP_CMD after create command"
    echo ""
    echo "Layout (WORKSPACE_INTERNAL_LAYOUT env var):"
    echo "  Format: <count><dir>[,<count><dir>,...] where dir is v/h/g"
    echo "  v = vertical splits (side by side), h = horizontal splits (stacked)"
    echo "  g = grid layout (equal squares, e.g., 4g = 2x2 grid)"
    echo "  Example: 4g = single window with 4 equal panes"
    exit 0
}

worktree_mode=false
add_worktree=false
run_setup=false
remove_worktree=false
close_session=false
minimize_panes=false
prune_worktrees=false
force_prune=false
sessionizer_mode=false
target_path=""
branch_name=""

create_tmux_layout() {
    local session_name="$1"
    local work_dir="$2"
    local layout="${WORKSPACE_INTERNAL_LAYOUT:-1v}"

    # Create initial session with first window
    tmux new-session -d -s "${session_name}" -c "${work_dir}"

    # Parse layout: format is "2v,3h,1v,4g" where number=panes, letter=direction (v/h/g for grid)
    IFS=',' read -ra windows <<< "$layout"
    local first_window=true

    for window_spec in "${windows[@]}"; do
        # Extract count and direction (e.g., "2v" -> count=2, dir=v)
        if [[ "$window_spec" =~ ^([0-9]+)([vhg])$ ]]; then
            local pane_count="${BASH_REMATCH[1]}"
            local direction="${BASH_REMATCH[2]}"

            if $first_window; then
                # Use the already created window
                first_window=false
                local target="${session_name}:0"
            else
                # Create new window
                tmux new-window -t "${session_name}" -c "${work_dir}"
                local target="${session_name}"
            fi

            if [[ "$direction" == "g" ]]; then
                # Grid layout: create panes and use tiled layout for equal distribution
                local splits_needed=$((pane_count - 1))
                for ((i=0; i<splits_needed; i++)); do
                    # Alternate between horizontal and vertical splits for better grid
                    if (( i % 2 == 0 )); then
                        tmux split-window -t "$target" -h -c "${work_dir}"
                    else
                        tmux split-window -t "$target" -v -c "${work_dir}"
                    fi
                done
                # Apply tiled layout for equal squares
                tmux select-layout -t "$target" "tiled"
            else
                # Create splits to reach desired pane count
                local splits_needed=$((pane_count - 1))
                for ((i=0; i<splits_needed; i++)); do
                    if [[ "$direction" == "v" ]]; then
                        tmux split-window -t "$target" -h -c "${work_dir}"
                    else
                        tmux split-window -t "$target" -v -c "${work_dir}"
                    fi
                done
                # Apply appropriate layout after all splits
                if [[ "$direction" == "v" ]]; then
                    tmux select-layout -t "$target" "even-horizontal"
                else
                    tmux select-layout -t "$target" "even-vertical"
                fi
            fi
        fi
    done

    # Select first window and first pane
    tmux select-window -t "${session_name}:0"
    tmux select-pane -t "${session_name}:0.0"
}

copy_env_files() {
    local source_dir="$1"
    local target_dir="$2"

    echo "Copying .env files from $source_dir to $target_dir"

    # Find all .env files in source directory and subdirectories
    find "$source_dir" -name ".env" -type f | while IFS= read -r env_file; do
        # Get relative path from source directory
        rel_path="${env_file#$source_dir/}"
        target_file="$target_dir/$rel_path"
        target_parent=$(dirname "$target_file")

        # Create target directory if it doesn't exist
        if [[ ! -d "$target_parent" ]]; then
            mkdir -p "$target_parent"
        fi

        # Copy .env file if target doesn't exist
        if [[ -f "$target_file" ]]; then
            echo "Preserving existing: $rel_path"
        else
            echo "Copying environment file: $rel_path"
            cp "$env_file" "$target_file"
        fi
    done
}

copy_pem_files() {
    local source_dir="$1"
    local target_dir="$2"

    echo "Copying .pem files from $source_dir to $target_dir"

    # Find all .pem files in source directory and subdirectories
    find "$source_dir" -name "*.pem" -type f | while IFS= read -r pem_file; do
        # Get relative path from source directory
        rel_path="${pem_file#$source_dir/}"
        target_file="$target_dir/$rel_path"
        target_parent=$(dirname "$target_file")

        # Create target directory if it doesn't exist
        if [[ ! -d "$target_parent" ]]; then
            mkdir -p "$target_parent"
        fi

        # Copy .pem file if target doesn't exist
        if [[ -f "$target_file" ]]; then
            echo "Preserving existing: $rel_path"
        else
            echo "Copying certificate file: $rel_path"
            cp "$pem_file" "$target_file"
        fi
    done
}

# Parse command (first argument)
if [[ $# -eq 0 ]]; then
    usage
fi

# Check for --worktree flag
if [[ $1 == "--worktree" ]]; then
    worktree_mode=true
    shift
    if [[ $# -eq 0 ]]; then
        usage
    fi
else
    sessionizer_mode=true
fi

command=$1
shift

# Parse options and arguments based on command and mode
case $command in
    open)
        # Common command: open existing directory with tmux session
        if [[ $# -eq 0 ]]; then
            # Use fzf to find git projects (repos + worktrees) up to 3 levels deep
            target_path=$(find "$(pwd)" -maxdepth 3 -name ".git" \( -type d -o -type f \) -exec dirname {} \; 2>/dev/null | sort -u | fzf)
            if [[ -z $target_path ]]; then
                exit 0
            fi
        else
            target_path=$(realpath "$1" 2>/dev/null)
            if [[ ! -d $target_path ]]; then
                echo "Error: '$1' is not a valid directory"
                exit 1
            fi
        fi
        ;;
    create)
        # Worktree mode only: create new git worktree
        if ! $worktree_mode; then
            echo "Error: 'create' command only available in worktree mode (use --worktree)"
            usage
        fi
        add_worktree=true
        if [[ $# -eq 0 ]]; then
            echo "Error: branch name required for 'create' command"
            usage
        fi
        branch_name=$1
        shift
        # Check for --setup flag
        while [[ $# -gt 0 ]]; do
            case $1 in
                --setup)
                    run_setup=true
                    ;;
                *)
                    echo "Unknown option for 'create': $1"
                    usage
                    ;;
            esac
            shift
        done
        ;;
    remove)
        if ! $worktree_mode; then
            echo "Error: 'remove' command only available in worktree mode (use --worktree)"
            usage
        fi
        remove_worktree=true
        if [[ $# -gt 0 && $1 != --* ]]; then
            branch_name=$1
        else
            branch_name=$(git branch --show-current)
        fi
        ;;
    close)
        close_session=true
        if [[ $# -gt 0 && $1 != --* ]]; then
            target_path=$1
        else
            # Auto-detect: use current tmux session name
            if [[ -n $TMUX ]]; then
                target_path=$(tmux display-message -p '#S')
            else
                echo "Error: Not in a tmux session and no session name provided"
                exit 1
            fi
        fi
        ;;
    minimize)
        minimize_panes=true
        if [[ $# -gt 0 && $1 != --* ]]; then
            target_path=$1
        else
            # Auto-detect: use current tmux session name
            if [[ -n $TMUX ]]; then
                target_path=$(tmux display-message -p '#S')
            else
                echo "Error: Not in a tmux session and no session name provided"
                exit 1
            fi
        fi
        ;;
    prune)
        if ! $worktree_mode; then
            echo "Error: 'prune' command only available in worktree mode (use --worktree)"
            usage
        fi
        prune_worktrees=true
        # Check for --force flag
        while [[ $# -gt 0 ]]; do
            case $1 in
                --force)
                    force_prune=true
                    ;;
                *)
                    echo "Unknown option for 'prune': $1"
                    usage
                    ;;
            esac
            shift
        done
        ;;
    help|--help|-h)
        usage
        ;;
    *)
        echo "Unknown command: $command"
        usage
        ;;
esac

# Open command: create/attach tmux session for directory
if [[ -n $target_path ]]; then
    # Try to get relative path from current directory
    current_dir="$(pwd)"
    if [[ "$target_path" == "$current_dir/"* ]]; then
        # Target is within current directory - use relative path
        selected_name="${target_path#$current_dir/}"
    else
        # Target is outside current directory - use basename
        selected_name=$(basename "$target_path")
    fi

    # Replace slashes and dots with underscores for tmux session name
    selected_name=$(echo "$selected_name" | tr './' '__')

    # Create session if it doesn't exist
    if ! tmux has-session -t="$selected_name" 2> /dev/null; then
        create_tmux_layout "$selected_name" "$target_path"
    fi

    # Attach or switch to session
    if [[ -z $TMUX ]]; then
        tmux attach -t "$selected_name"
    else
        tmux switch-client -t "$selected_name"
    fi
    exit 0
fi

# Handle close and minimize for both modes
if $close_session; then
    session_name="${target_path:-$branch_name}"
    if tmux has-session -t "$session_name" 2>/dev/null; then
        # Just kill the session - tmux handles detaching automatically if we're inside it
        tmux kill-session -t "$session_name"
    else
        echo "No tmux session found: $session_name"
    fi
    exit 0
fi

if $minimize_panes; then
    session_name="${target_path:-$branch_name}"
    if ! tmux has-session -t "$session_name" 2>/dev/null; then
        echo "No tmux session found: $session_name"
        exit 1
    fi

    echo "Closing nvim panes in session: $session_name"
    # List all panes in the session and close nvim instances
    tmux list-panes -s -t "$session_name" -F "#{pane_id} #{pane_current_command}" | \
    while read -r pane_id pane_command; do
        if [[ "$pane_command" == "nvim" || "$pane_command" == "vim" ]]; then
            echo "  Closing nvim in pane $pane_id"
            tmux send-keys -t "$pane_id" Escape ":qa!" C-m 2>/dev/null || true
        fi
    done
    exit 0
fi

if $prune_worktrees; then
    base_path=$(git rev-parse --show-toplevel)
    protected=(_main _master main master)

    echo "Scanning worktrees for pruning..."

    # Get list of all worktrees (excluding main worktree)
    git worktree list --porcelain | awk '
        /^worktree / { path=$2 }
        /^branch / {
            branch=$2
            sub(/^refs\/heads\//, "", branch)
            if (path && branch) print path "|" branch
            path=""; branch=""
        }
    ' | while IFS='|' read -r worktree_path branch_name; do
        # Skip if this is the main worktree
        [[ "$worktree_path" == "$base_path" ]] && continue

        # Skip protected branches
        is_protected=false
        for p in "${protected[@]}"; do
            if [[ "$branch_name" == "$p" ]]; then
                is_protected=true
                break
            fi
        done
        [[ "$is_protected" == "true" ]] && continue

        # Check if tmux session exists
        if tmux has-session -t "$branch_name" 2>/dev/null; then
            echo "â­  Skipping $branch_name (tmux session active)"
            continue
        fi

        # Check if working tree is clean (skip this check if --force is used)
        if ! $force_prune && [[ -n $(cd "$worktree_path" && git status --porcelain) ]]; then
            echo "â­  Skipping $branch_name (uncommitted changes)"
            continue
        fi

        # Safe to remove
        if $force_prune && [[ -n $(cd "$worktree_path" && git status --porcelain) ]]; then
            echo "ðŸ—‘  Removing $branch_name (forced, uncommitted changes present)"
        else
            echo "ðŸ—‘  Removing $branch_name (no session, clean working tree)"
        fi
        git worktree remove --force "$worktree_path" 2>/dev/null || {
            echo "   Failed to remove $worktree_path, trying to clean up..."
            # Kill stray processes
            if command -v lsof &>/dev/null; then
                pids=$(lsof +D "$worktree_path" -t 2>/dev/null)
            else
                pids=$(ps -eo pid,cmd | awk -v p="$worktree_path" '$0~p{print $1}')
            fi
            [[ -n "$pids" ]] && echo "$pids" | xargs -r kill 2>/dev/null
            git worktree remove --force "$worktree_path" 2>/dev/null || echo "   Could not remove $worktree_path"
        }
    done

    echo "Prune complete."
    exit 0
fi

# Worktree mode: remaining commands require git context
base_path=$(git rev-parse --show-toplevel)
worktree_path="$base_path/../${branch_name}"

if $remove_worktree; then
    protected=(_main _master main master)
    for p in "${protected[@]}"; do
        [[ "${branch_name}" == "${p}" ]] && {
            echo "Refusing to remove protected branch: ${p}"
            exit 1
        }
    done

    workdir="$base_path/../${branch_name}"
    [[ ! -d "$workdir" ]] && { echo "Cannot resolve worktree for ${branch_name}"; exit 1; }
    abs=$(command -v realpath &>/dev/null && realpath "$workdir" || cd "$workdir" && pwd -P)

    reg=$(git worktree list --porcelain | awk '$1=="worktree"{print $2}')
    if echo "$reg" | grep -Fxq "$abs"; then
        echo "Removing worktree: $abs"
        git worktree remove --force "$abs" || { echo "Failed removing worktree $abs"; exit 1; }
    else
        echo "No registered worktree at $abs"; exit 1
    fi

    # kill stray processes
    if command -v lsof &>/dev/null; then
        pids=$(lsof +D "$abs" -t 2>/dev/null)
    else
        pids=$(ps -eo pid,cmd | awk -v p="$abs" '$0~p{print $1}')
    fi
    [[ -n "$pids" ]] && echo "$pids" | xargs -r kill

    exit 0
fi

if $add_worktree; then
    # Always fetch latest changes from remote
    echo "Fetching latest changes from remote..."
    git fetch

    # Create worktree if missing
    if [[ -d "${worktree_path}" ]]; then
        echo "Reusing existing worktree at: ${worktree_path}"
        [[ ! -e "${worktree_path}/.git" ]] && { echo "Error: ${worktree_path} is not a git worktree"; exit 1; }

        # Smart pull with safety checks for existing worktree
        (
            cd "${worktree_path}"

            # Check if branch has a remote tracking branch
            if ! git rev-parse --abbrev-ref --symbolic-full-name @{u} &>/dev/null; then
                echo "Local-only branch (no remote tracking). Skipping pull."
            else
                # Check if working tree is clean
                if [[ -n $(git status --porcelain) ]]; then
                    echo "âš ï¸  Working tree has uncommitted changes. Skipping auto-pull."
                    echo "Run 'git status' in the worktree to see changes."
                else
                    # Check if we can fast-forward
                    LOCAL=$(git rev-parse @)
                    REMOTE=$(git rev-parse @{u})
                    BASE=$(git merge-base @ @{u})

                    if [[ "$LOCAL" == "$REMOTE" ]]; then
                        echo "Already up to date with remote."
                    elif [[ "$LOCAL" == "$BASE" ]]; then
                        echo "Fast-forwarding to latest changes..."
                        git pull --ff-only
                    else
                        echo "âš ï¸  Branch has diverged from remote (local commits or needs rebase)."
                        echo "Run 'git pull' manually in the worktree to merge/rebase changes."
                        git --no-pager log --oneline --decorate --left-right --graph @...@{u} 2>/dev/null | head -10 || true
                    fi
                fi
            fi
        )
    else
        # Check if branch exists on remote
        if git show-ref --verify --quiet "refs/remotes/origin/${branch_name}"; then
            echo "Creating worktree from remote branch: origin/${branch_name}"
            git worktree add --checkout -b "${branch_name}" "${worktree_path}" "origin/${branch_name}"
        else
            echo "Creating worktree with new local branch: ${branch_name}"
            git worktree add --checkout -B "${branch_name}" "${worktree_path}"
        fi
    fi

    # Tmux session cleanup
    if tmux has-session -t "${branch_name}" 2>/dev/null; then
        echo "Killing existing tmux session: ${branch_name}"
        tmux kill-session -t "${branch_name}"
    fi

    # Create tmux session with configured layout
    create_tmux_layout "${branch_name}" "${worktree_path}"

    # Set worktree environment variables
    for var_name in $(printenv | grep -oE '^worktree_[^=]+' | grep -v '^worktree_INTERNAL'); do
        env_key="${var_name#worktree_}"
        env_value="${!var_name}"
        tmux set-environment -t "${branch_name}" "${env_key}" "${env_value}"
    done

    # Copy all .env files from parent worktree to new worktree
    copy_env_files "$base_path" "$worktree_path"

    # Copy all .pem files from parent worktree to new worktree
    copy_pem_files "$base_path" "$worktree_path"

    # Post-setup commands
    if $run_setup; then
        if [[ -z "${WORKSPACE_INTERNAL_SETUP_CMD}" ]]; then
            echo "Error: WORKSPACE_INTERNAL_SETUP_CMD is not set"
            exit 1
        fi
        tmux send-keys -t "${branch_name}" "${WORKSPACE_INTERNAL_SETUP_CMD}" C-m
    fi

    if [[ -n "$TMUX" ]]; then
      tmux switch-client -t "${branch_name}"
    else
      tmux attach-session -t "${branch_name}"
    fi
fi
